script_path = output_path / "compile_proto.sh"
await self.file_manager.write_file(script_path, compile_script)
generated_files['compile_proto.sh'] = str(script_path)

return generated_files

# text2api/generators/websocket_gen.py

"""
Generator dla WebSocket API
"""

from pathlib import Path
from typing import Dict
from jinja2 import Environment, DictLoader

from ..core.analyzer import ApiSpec
from ..utils.file_utils import FileManager


class WebSocketGenerator:
    """Generator kodu WebSocket"""

    def __init__(self):
        self.file_manager = FileManager()
        self.templates = self._load_templates()

    def _load_templates(self) -> Environment:
        """≈Åaduje szablony Jinja2 dla WebSocket"""

        templates = {
            'server.py': '''"""
WebSocket server generated by text2api
"""

import asyncio
import websockets
import json
import logging
from typing import Dict, Set, Any
from datetime import datetime
import os
{% if api_spec.database_required %}
import sqlite3
import threading
{% endif %}

class {{ api_spec.name | title }}WebSocketServer:
    """{{ api_spec.description }}"""

    def __init__(self):
        self.clients: Set[websockets.WebSocketServerProtocol] = set()
        self.rooms: Dict[str, Set[websockets.WebSocketServerProtocol]] = {}
        {% if api_spec.database_required %}
        self.db_path = "{{ api_spec.name }}.db"
        self.db_lock = threading.Lock()
        self._init_database()
        {% endif %}
        logging.info("{{ api_spec.name | title }} WebSocket Server initialized")

    {% if api_spec.database_required %}
    def _init_database(self):
        """Initialize SQLite database"""
        with self.db_lock:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            {% for model in api_spec.models %}
            # Create {{ model.name }} table
            cursor.execute('''
            CREATE TABLE IF NOT EXISTS {{model.name.lower()}}s(
                { % for field in model.fields %}
        {{field.name}}
        { % if field.type == 'integer' %}INTEGER
        { % elif field.type == 'string' %}TEXT
        { % elif field.type == 'boolean' %}BOOLEAN
        { % else %}TEXT
        { % endif %}{ % if field.get('primary_key') %} PRIMARY
        KEY
        { % endif %}{ % if not loop.last %}, { % endif %}
        { % endfor %}
        )
        ''')
        {% endfor %}

        # Create messages table for chat functionality
        cursor.execute('''
        CREATE
        TABLE
        IF
        NOT
        EXISTS
        messages(
            id
        INTEGER
        PRIMARY
        KEY,
        room
        TEXT,
        user
        TEXT,
        message
        TEXT,
        timestamp
        DATETIME
        DEFAULT
        CURRENT_TIMESTAMP
        )
        ''')

        conn.commit()
        conn.close()

def _get_db_connection(self):
    """Get database connection"""
    return sqlite3.connect(self.db_path)
{% endif %}

async def register_client(self, websocket: websockets.WebSocketServerProtocol):
    """Register new client"""
    self.clients.add(websocket)
    await self.send_to_client(websocket, {
        "type": "connected",
        "message": "Connected to {{ api_spec.name }}",
        "timestamp": datetime.now().isoformat()
    })
    logging.info(f"Client {websocket.remote_address} connected. Total clients: {len(self.clients)}")

async def unregister_client(self, websocket: websockets.WebSocketServerProtocol):
    """Unregister client"""
    self.clients.discard(websocket)

    # Remove from all rooms
    for room_clients in self.rooms.values():
        room_clients.discard(websocket)

    logging.info(f"Client {websocket.remote_address} disconnected. Total clients: {len(self.clients)}")

async def join_room(self, websocket: websockets.WebSocketServerProtocol, room: str):
    """Join client to room"""
    if room not in self.rooms:
        self.rooms[room] = set()

    self.rooms[room].add(websocket)

    await self.send_to_client(websocket, {
        "type": "room_joined",
        "room": room,
        "message": f"Joined room: {room}",
        "timestamp": datetime.now().isoformat()
    })

    # Notify other clients in room
    await self.broadcast_to_room(room, {
        "type": "user_joined",
        "room": room,
        "message": "A user joined the room",
        "timestamp": datetime.now().isoformat()
    }, exclude=websocket)

async def leave_room(self, websocket: websockets.WebSocketServerProtocol, room: str):
    """Remove client from room"""
    if room in self.rooms:
        self.rooms[room].discard(websocket)

        # Notify other clients in room
        await self.broadcast_to_room(room, {
            "type": "user_left",
            "room": room,
            "message": "A user left the room",
            "timestamp": datetime.now().isoformat()
        }, exclude=websocket)

async def send_to_client(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
    """Send data to specific client"""
    try:
        await websocket.send(json.dumps(data))
    except websockets.exceptions.ConnectionClosed:
        await self.unregister_client(websocket)

async def broadcast_to_all(self, data: Dict[str, Any]):
    """Broadcast data to all connected clients"""
    if self.clients:
        await asyncio.gather(
            *[self.send_to_client(client, data) for client in self.clients.copy()],
            return_exceptions=True
        )

async def broadcast_to_room(self, room: str, data: Dict[str, Any], exclude=None):
    """Broadcast data to all clients in room"""
    if room in self.rooms:
        clients = self.rooms[room].copy()
        if exclude:
            clients.discard(exclude)

        if clients:
            await asyncio.gather(
                *[self.send_to_client(client, data) for client in clients],
                return_exceptions=True
            )

async def handle_message(self, websocket: websockets.WebSocketServerProtocol, message: str):
    """Handle incoming message from client"""
    try:
        data = json.loads(message)
        message_type = data.get("type")

        if message_type == "ping":
            await self.handle_ping(websocket, data)
        elif message_type == "join_room":
            await self.handle_join_room(websocket, data)
        elif message_type == "leave_room":
            await self.handle_leave_room(websocket, data)
        elif message_type == "chat_message":
            await self.handle_chat_message(websocket, data)
        {% for model in api_spec.models %}
        elif message_type == "create_{{ model.name.lower() }}":
            await self.handle_create_{{ model.name.lower() }}(websocket, data)
        elif message_type == "get_{{ model.name.lower() }}":
            await self.handle_get_{{ model.name.lower() }}(websocket, data)
        elif message_type == "list_{{ model.name.lower() }}s":
            await self.handle_list_{{ model.name.lower() }}s(websocket, data)
        {% endfor %}
        else:
            await self.send_to_client(websocket, {
                "type": "error",
                "message": f"Unknown message type: {message_type}",
                "timestamp": datetime.now().isoformat()
            })

    except json.JSONDecodeError:
        await self.send_to_client(websocket, {
            "type": "error",
            "message": "Invalid JSON format",
            "timestamp": datetime.now().isoformat()
        })
    except Exception as e:
        logging.error(f"Error handling message: {e}")
        await self.send_to_client(websocket, {
            "type": "error",
            "message": f"Internal server error: {str(e)}",
            "timestamp": datetime.now().isoformat()
        })

async def handle_ping(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
    """Handle ping message"""
    await self.send_to_client(websocket, {
        "type": "pong",
        "timestamp": datetime.now().isoformat()
    })

async def handle_join_room(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
    """Handle join room request"""
    room = data.get("room")
    if room:
        await self.join_room(websocket, room)
    else:
        await self.send_to_client(websocket, {
            "type": "error",
            "message": "Room name required",
            "timestamp": datetime.now().isoformat()
        })

async def handle_leave_room(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
    """Handle leave room request"""
    room = data.get("room")
    if room:
        await self.leave_room(websocket, room)

async def handle_chat_message(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
    """Handle chat message"""
    room = data.get("room", "general")
    user = data.get("user", "Anonymous")
    message = data.get("message", "")

    if not message:
        await self.send_to_client(websocket, {
            "type": "error",
            "message": "Message content required",
            "timestamp": datetime.now().isoformat()
        })
        return

    {% if api_spec.database_required %}
    # Save message to database
    with self.db_lock:
        conn = self._get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO messages (room, user, message) VALUES (?, ?, ?)",
            (room, user, message)
        )
        conn.commit()
        conn.close()
    {% endif %}

    # Broadcast message to room
    await self.broadcast_to_room(room, {
        "type": "chat_message",
        "room": room,
        "user": user,
        "message": message,
        "timestamp": datetime.now().isoformat()
    })

{% for model in api_spec.models %}
async def handle_create_{{ model.name.lower() }}(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
    """Handle create {{ model.name.lower() }} request"""
    try:
        {% if api_spec.database_required %}
        with self.db_lock:
            conn = self._get_db_connection()
            cursor = conn.cursor()

            cursor.execute('''
        INSERT
        INTO
        {{model.name.lower()}}
        s({ % for field in model.fields %}{ % if field.name != 'id' and not field.get('auto_now_add') %}{{field.name}}
        { % if not loop.last %}, { % endif %}{ % endif %}{ % endfor %})
        VALUES({ % for field in model.fields %}{ % if field.name != 'id' and not field.get(
            'auto_now_add') %}?{ % if not loop.last %}, { % endif %}{ % endif %}{ % endfor %})
        ''', ({% for field in model.fields %}{% if field.name != 'id' and not field.get('auto_now_add') %}data.get('{{ field.name }}'){% if not loop.last %}, {% endif %}{% endif %}{% endfor %}))

        item_id = cursor.lastrowid
        conn.commit()
        conn.close()

    response_data = {
        "type": "{{ model.name.lower() }}_created",
        "data": {
            "id": item_id,
            {% for field in model.fields %}
            {% if field.name != 'id' and not field.get('auto_now_add') %}
            "{{ field.name }}": data.get('{{ field.name }}'){% if not loop.last %},{% endif %}
            {% endif %}
            {% endfor %}
        },
        "timestamp": datetime.now().isoformat()
    }
    {% else %}
    # Mock response
    response_data = {
        "type": "{{ model.name.lower() }}_created",
        "data": {
            "id": 1,
            {% for field in model.fields %}
            {% if field.name != 'id' and not field.get('auto_now_add') %}
            "{{ field.name }}": data.get('{{ field.name }}'){% if not loop.last %},{% endif %}
            {% endif %}
            {% endfor %}
        },
        "timestamp": datetime.now().isoformat()
    }
    {% endif %}

    await self.send_to_client(websocket, response_data)

    # Broadcast to all clients if specified
    if data.get("broadcast", False):
        await self.broadcast_to_all(response_data)

except Exception as e:
    await self.send_to_client(websocket, {
        "type": "error",
        "message": f"Error creating {{ model.name.lower() }}: {str(e)}",
        "timestamp": datetime.now().isoformat()
    })

async def handle_get_{{ model.name.lower() }}(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
"""Handle get {{ model.name.lower() }} request"""
try:
    item_id = data.get("id")
    if not item_id:
        await self.send_to_client(websocket, {
            "type": "error",
            "message": "ID required",
            "timestamp": datetime.now().isoformat()
        })
        return

    {% if api_spec.database_required %}
    with self.db_lock:
        conn = self._get_db_connection()
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM {{ model.name.lower() }}s WHERE id = ?', (item_id,))
        row = cursor.fetchone()
        conn.close()

    if not row:
        await self.send_to_client(websocket, {
            "type": "error",
            "message": "{{ model.name }} not found",
            "timestamp": datetime.now().isoformat()
        })
        return

    response_data = {
        "type": "{{ model.name.lower() }}_data",
        "data": {
            {% for field in model.fields %}
            "{{ field.name }}": row[{{ loop.index0 }}]{% if not loop.last %},{% endif %}
            {% endfor %}
        },
        "timestamp": datetime.now().isoformat()
    }
    {% else %}
    # Mock response
    response_data = {
        "type": "{{ model.name.lower() }}_data",
        "data": {
            "id": item_id,
            {% for field in model.fields %}
            {% if field.name != 'id' %}
            "{{ field.name }}": "Sample {{ field.name }}"{% if not loop.last %},{% endif %}
            {% endif %}
            {% endfor %}
        },
        "timestamp": datetime.now().isoformat()
    }
    {% endif %}

    await self.send_to_client(websocket, response_data)

except Exception as e:
    await self.send_to_client(websocket, {
        "type": "error",
        "message": f"Error getting {{ model.name.lower() }}: {str(e)}",
        "timestamp": datetime.now().isoformat()
    })

async def handle_list_{{ model.name.lower() }}s(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
"""Handle list {{ model.name.lower() }}s request"""
try:
    {% if api_spec.database_required %}
    with self.db_lock:
        conn = self._get_db_connection()
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM {{ model.name.lower() }}s')
        rows = cursor.fetchall()
        conn.close()

    items = []
    for row in rows:
        items.append({
            {% for field in model.fields %}
            "{{ field.name }}": row[{{ loop.index0 }}]{% if not loop.last %},{% endif %}
            {% endfor %}
        })

    response_data = {
        "type": "{{ model.name.lower() }}s_list",
        "data": {
            "items": items,
            "total": len(items)
        },
        "timestamp": datetime.now().isoformat()
    }
    {% else %}
    # Mock response
    response_data = {
        "type": "{{ model.name.lower() }}s_list",
        "data": {
            "items": [
                {
                    "id": 1,
                    {% for field in model.fields %}
                    {% if field.name != 'id' %}
                    "{{ field.name }}": "Sample {{ field.name }}"{% if not loop.last %},{% endif %}
                    {% endif %}
                    {% endfor %}
                }
            ],
            "total": 1
        },
        "timestamp": datetime.now().isoformat()
    }
    {% endif %}

    await self.send_to_client(websocket, response_data)

except Exception as e:
    await self.send_to_client(websocket, {
        "type": "error",
        "message": f"Error listing {{ model.name.lower() }}s: {str(e)}",
        "timestamp": datetime.now().isoformat()
    })

{% endfor %}

async def handle_client(self, websocket: websockets.WebSocketServerProtocol, path: str):
"""Handle client connection"""
await self.register_client(websocket)

try:
    async for message in websocket:
        await self.handle_message(websocket, message)
except websockets.exceptions.ConnectionClosed:
    pass
finally:
    await self.unregister_client(websocket)

def create_server():
"""Create and return WebSocket server"""
server_instance = {{ api_spec.name | title }}WebSocketServer()

return websockets.serve(
server_instance.handle_client,
host=os.getenv('HOST', 'localhost'),
port=int(os.getenv('PORT', '8765'))
)

async def main():
"""Main server function"""
logging.basicConfig(
level=logging.INFO,
format='%(asctime)s - %(levelname)s - %(message)s'
)

server = await create_server()
logging.info(f"{{ api_spec.name | title }} WebSocket server started on ws://localhost:8765")

# Keep server running
await server.wait_closed()

if __name__ == '__main__':
asyncio.run(main())
''',

        'client_example.py': '''"""
WebSocket client example for {{ api_spec.name }}
"""

import asyncio
import websockets
import json
from datetime import datetime

class {{ api_spec.name | title }}Client:
    """Example WebSocket client"""

    def __init__(self, uri="ws://localhost:8765"):
        self.uri = uri
        self.websocket = None

    async def connect(self):
        """Connect to WebSocket server"""
        self.websocket = await websockets.connect(self.uri)
        print(f"Connected to {self.uri}")

    async def disconnect(self):
        """Disconnect from server"""
        if self.websocket:
            await self.websocket.close()
            print("Disconnected from server")

    async def send_message(self, message_data):
        """Send message to server"""
        if self.websocket:
            await self.websocket.send(json.dumps(message_data))

    async def listen_for_messages(self):
        """Listen for incoming messages"""
        try:
            async for message in self.websocket:
                data = json.loads(message)
                await self.handle_message(data)
        except websockets.exceptions.ConnectionClosed:
            print("Connection closed by server")

    async def handle_message(self, data):
        """Handle incoming message"""
        message_type = data.get("type")
        timestamp = data.get("timestamp", "")

        if message_type == "connected":
            print(f"[{timestamp}] {data.get('message')}")
        elif message_type == "chat_message":
            user = data.get("user", "Unknown")
            room = data.get("room", "general")
            message = data.get("message", "")
            print(f"[{room}] {user}: {message}")
        elif message_type == "error":
            print(f"ERROR: {data.get('message')}")
        else:
            print(f"Received: {data}")

    async def run_example(self):
        """Run example client interactions"""
        await self.connect()

        # Start listening for messages
        listen_task = asyncio.create_task(self.listen_for_messages())

        # Wait a bit for connection
        await asyncio.sleep(1)

        # Example interactions
        print("\\n=== Example Interactions ===")

        # Ping server
        await self.send_message({"type": "ping"})
        await asyncio.sleep(1)

        # Join a room
        await self.send_message({
            "type": "join_room",
            "room": "test_room"
        })
        await asyncio.sleep(1)

        # Send chat message
        await self.send_message({
            "type": "chat_message",
            "room": "test_room",
            "user": "TestUser",
            "message": "Hello from WebSocket client!"
        })
        await asyncio.sleep(1)

        {% for model in api_spec.models %}
        # {{ model.name }} operations
        print(f"\\n--- {{ model.name }} Operations ---")

        # Create {{ model.name.lower() }}
        await self.send_message({
            "type": "create_{{ model.name.lower() }}",
            {% for field in model.fields %}
            {% if field.name != 'id' and not field.get('auto_now_add') %}
            "{{ field.name }}": "Test {{ field.name }}",
            {% endif %}
            {% endfor %}
            "broadcast": True
        })
        await asyncio.sleep(1)

        # List {{ model.name.lower() }}s
        await self.send_message({
            "type": "list_{{ model.name.lower() }}s"
        })
        await asyncio.sleep(1)

        {% endfor %}

        # Wait a bit more for responses
        await asyncio.sleep(3)

        # Cancel listening task and disconnect
        listen_task.cancel()
        await self.disconnect()

async def main():
    """Main client function"""
    client = {{ api_spec.name | title }}Client()
    await client.run_example()

if __name__ == '__main__':
    asyncio.run(main())
''',

        'requirements.txt': '''websockets==12.0
{% if api_spec.database_required %}
sqlite3
{% endif %}
python-dotenv==1.0.0
''',

        '.env.example': '''# Environment variables for {{ api_spec.name }}

HOST=localhost
PORT=8765
{% if api_spec.database_required %}
DATABASE_PATH={{ api_spec.name }}.db
{% endif %}
LOG_LEVEL=INFO
'''
        }

        return Environment(loader=DictLoader(templates))

    async def generate(self, api_spec: ApiSpec, output_path: Path) -> Dict[str, str]:
        """Generuje kod WebSocket"""

        await self.file_manager.ensure_directory(output_path)
        generated_files = {}

        # Generuj server
        server_content = self.templates.get_template('server.py').render(api_spec=api_spec)
        server_path = output_path / "server.py"
        await self.file_manager.write_file(server_path, server_content)
        generated_files['server.py'] = str(server_path)

        # Generuj client example
        client_content = self.templates.get_template('client_example.py').render(api_spec=api_spec)
        client_path = output_path / "client_example.py"
        await self.file_manager.write_file(client_path, client_content)
        generated_files['client_example.py'] = str(client_path)

        # Generuj requirements
        req_content = self.templates.get_template('requirements.txt').render(api_spec=api_spec)
        req_path = output_path / "requirements.txt"
        await self.file_manager.write_file(req_path, req_content)
        generated_files['requirements.txt'] = str(req_path)

        # Generuj .env.example
        env_content = self.templates.get_template('.env.example').render(api_spec=api_spec)
        env_path = output_path / ".env.example"
        await self.file_manager.write_file(env_path, env_content)
        generated_files['.env.example'] = str(env_path)

        return generated_files


