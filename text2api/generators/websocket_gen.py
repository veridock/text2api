# text2api/generators/websocket_gen.py

"""
Generator dla WebSocket API
"""

from pathlib import Path
from typing import Dict
from jinja2 import Environment, DictLoader

from ..core.analyzer import ApiSpec
from ..utils.file_utils import FileManager


class WebSocketGenerator:
    """Generator kodu WebSocket"""

    def __init__(self):
        self.file_manager = FileManager()
        self.templates = self._load_templates()

    def _load_templates(self) -> Environment:
        """≈Åaduje szablony Jinja2 dla WebSocket"""

        templates = {
            'server.py': '''"""
WebSocket server generated by text2api
"""

import asyncio
import websockets
import json
import logging
from typing import Dict, Set, Any
from datetime import datetime
import os
{% if api_spec.database_required %}
import sqlite3
import threading
{% endif %}

class {{ api_spec.name | title }}WebSocketServer:
    """{{ api_spec.description }}"""

    def __init__(self):
        self.clients: Set[websockets.WebSocketServerProtocol] = set()
        self.rooms: Dict[str, Set[websockets.WebSocketServerProtocol]] = {}
        {% if api_spec.database_required %}
        self.db_path = "{{ api_spec.name }}.db"
        self.db_lock = threading.Lock()
        self._init_database()
        {% endif %}
        logging.info("{{ api_spec.name | title }} WebSocket Server initialized")

    {% if api_spec.database_required %}
    def _init_database(self):
        """Initialize SQLite database"""
        with self.db_lock:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            {% for model in api_spec.models %}
            # Create {{ model.name }} table
            cursor.execute('''
            CREATE TABLE IF NOT EXISTS {{model.name.lower()}}s(
                { % for field in model.fields %}
        {{field.name}}
        { % if field.type == 'integer' %}INTEGER
        { % elif field.type == 'string' %}TEXT
        { % elif field.type == 'boolean' %}BOOLEAN
        { % else %}TEXT
        { % endif %}{ % if field.get('primary_key') %} PRIMARY
        KEY
        { % endif %}{ % if not loop.last %}, { % endif %}
        { % endfor %}
        )
        ''')
        {% endfor %}

        # Create messages table for chat functionality
        cursor.execute('''
        CREATE
        TABLE
        IF
        NOT
        EXISTS
        messages(
            id
        INTEGER
        PRIMARY
        KEY,
        room
        TEXT,
        user
        TEXT,
        message
        TEXT,
        timestamp
        DATETIME
        DEFAULT
        CURRENT_TIMESTAMP
        )
        ''')

        conn.commit()
        conn.close()

def _get_db_connection(self):
    """Get database connection"""
    return sqlite3.connect(self.db_path)
{% endif %}

async def register_client(self, websocket: websockets.WebSocketServerProtocol):
    """Register new client"""
    self.clients.add(websocket)
    await self.send_to_client(websocket, {
        "type": "connected",
        "message": "Connected to {{ api_spec.name }}",
        "timestamp": datetime.now().isoformat()
    })
    logging.info(f"Client {websocket.remote_address} connected. Total clients: {len(self.clients)}")

async def unregister_client(self, websocket: websockets.WebSocketServerProtocol):
    """Unregister client"""
    self.clients.discard(websocket)

    # Remove from all rooms
    for room_clients in self.rooms.values():
        room_clients.discard(websocket)

    logging.info(f"Client {websocket.remote_address} disconnected. Total clients: {len(self.clients)}")

async def join_room(self, websocket: websockets.WebSocketServerProtocol, room: str):
    """Join client to room"""
    if room not in self.rooms:
        self.rooms[room] = set()

    self.rooms[room].add(websocket)

    await self.send_to_client(websocket, {
        "type": "room_joined",
        "room": room,
        "message": f"Joined room: {room}",
        "timestamp": datetime.now().isoformat()
    })

    # Notify other clients in room
    await self.broadcast_to_room(room, {
        "type": "user_joined",
        "room": room,
        "message": "A user joined the room",
        "timestamp": datetime.now().isoformat()
    }, exclude=websocket)

async def leave_room(self, websocket: websockets.WebSocketServerProtocol, room: str):
    """Remove client from room"""
    if room in self.rooms:
        self.rooms[room].discard(websocket)

        # Notify other clients in room
        await self.broadcast_to_room(room, {
            "type": "user_left",
            "room": room,
            "message": "A user left the room",
            "timestamp": datetime.now().isoformat()
        }, exclude=websocket)

async def send_to_client(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
    """Send data to specific client"""
    try:
        await websocket.send(json.dumps(data))
    except websockets.exceptions.ConnectionClosed:
        await self.unregister_client(websocket)

async def broadcast_to_all(self, data: Dict[str, Any]):
    """Broadcast data to all connected clients"""
    if self.clients:
        await asyncio.gather(
            *[self.send_to_client(client, data) for client in self.clients.copy()],
            return_exceptions=True
        )

async def broadcast_to_room(self, room: str, data: Dict[str, Any], exclude=None):
    """Broadcast data to all clients in room"""
    if room in self.rooms:
        clients = self.rooms[room].copy()
        if exclude:
            clients.discard(exclude)

        if clients:
            await asyncio.gather(
                *[self.send_to_client(client, data) for client in clients],
                return_exceptions=True
            )

async def handle_message(self, websocket: websockets.WebSocketServerProtocol, message: str):
    """Handle incoming message from client"""
    try:
        data = json.loads(message)
        message_type = data.get("type")

        if message_type == "ping":
            await self.handle_ping(websocket, data)
        elif message_type == "join_room":
            await self.handle_join_room(websocket, data)
        elif message_type == "leave_room":
            await self.handle_leave_room(websocket, data)
        elif message_type == "chat_message":
            await self.handle_chat_message(websocket, data)
        {% for model in api_spec.models %}
        elif message_type == "create_{{ model.name.lower() }}":
            await self.handle_create_{{ model.name.lower() }}(websocket, data)
        elif message_type == "get_{{ model.name.lower() }}":
            await self.handle_get_{{ model.name.lower() }}(websocket, data)
        elif message_type == "list_{{ model.name.lower() }}s":
            await self.handle_list_{{ model.name.lower() }}s(websocket, data)
        {% endfor %}
        else:
            await self.send_to_client(websocket, {
                "type": "error",
                "message": f"Unknown message type: {message_type}",
                "timestamp": datetime.now().isoformat()
            })

    except json.JSONDecodeError:
        await self.send_to_client(websocket, {
            "type": "error",
            "message": "Invalid JSON format",
            "timestamp": datetime.now().isoformat()
        })
    except Exception as e:
        logging.error(f"Error handling message: {e}")
        await self.send_to_client(websocket, {
            "type": "error",
            "message": f"Internal server error: {str(e)}",
            "timestamp": datetime.now().isoformat()
        })

async def handle_ping(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
    """Handle ping message"""
    await self.send_to_client(websocket, {
        "type": "pong",
        "timestamp": datetime.now().isoformat()
    })

async def handle_join_room(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
    """Handle join room request"""
    room = data.get("room")
    if room:
        await self.join_room(websocket, room)
    else:
        await self.send_to_client(websocket, {
            "type": "error",
            "message": "Room name required",
            "timestamp": datetime.now().isoformat()
        })

async def handle_leave_room(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
    """Handle leave room request"""
    room = data.get("room")
    if room:
        await self.leave_room(websocket, room)

async def handle_chat_message(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
    """Handle chat message"""
    room = data.get("room", "general")
    user = data.get("user", "Anonymous")
    message = data.get("message", "")

    if not message:
        await self.send_to_client(websocket, {
            "type": "error",
            "message": "Message content required",
            "timestamp": datetime.now().isoformat()
        })
        return

    {% if api_spec.database_required %}
    # Save message to database
    with self.db_lock:
        conn = self._get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO messages (room, user, message) VALUES (?, ?, ?)",
            (room, user, message)
        )
        conn.commit()
        conn.close()
    {% endif %}

    # Broadcast message to room
    await self.broadcast_to_room(room, {
        "type": "chat_message",
        "room": room,
        "user": user,
        "message": message,
        "timestamp": datetime.now().isoformat()
    })

{% for model in api_spec.models %}
async def handle_create_{{ model.name.lower() }}(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
    """Handle create {{ model.name.lower() }} request"""
    try:
        {% if api_spec.database_required %}
        with self.db_lock:
            conn = self._get_db_connection()
            cursor = conn.cursor()

            cursor.execute('''
        INSERT
        INTO
        {{model.name.lower()}}
        s({ % for field in model.fields %}{ % if field.name != 'id' and not field.get('auto_now_add') %}{{field.name}}
        { % if not loop.last %}, { % endif %}{ % endif %}{ % endfor %})
        VALUES({ % for field in model.fields %}{ % if field.name != 'id' and not field.get(
            'auto_now_add') %}?{ % if not loop.last %}, { % endif %}{ % endif %}{ % endfor %})
        ''', ({% for field in model.fields %}{% if field.name != 'id' and not field.get('auto_now_add') %}data.get('{{ field.name }}'){% if not loop.last %}, {% endif %}{% endif %}{% endfor %}))

        item_id = cursor.lastrowid
        conn.commit()
        conn.close()

    response_data = {
        "type": "{{ model.name.lower() }}_created",
        "data": {
            "id": item_id,
            {% for field in model.fields %}
            {% if field.name != 'id' and not field.get('auto_now_add') %}
            "{{ field.name }}": data.get('{{ field.name }}'){% if not loop.last %},{% endif %}
            {% endif %}
            {% endfor %}
        },
        "timestamp": datetime.now().isoformat()
    }
    {% else %}
    # Mock response
    response_data = {
        "type": "{{ model.name.lower() }}_created",
        "data": {
            "id": 1,
            {% for field in model.fields %}
            {% if field.name != 'id' and not field.get('auto_now_add') %}
            "{{ field.name }}": data.get('{{ field.name }}'){% if not loop.last %},{% endif %}
            {% endif %}
            {% endfor %}
        },
        "timestamp": datetime.now().isoformat()
    }
    {% endif %}

    await self.send_to_client(websocket, response_data)

    # Broadcast to all clients if specified
    if data.get("broadcast", False):
        await self.broadcast_to_all(response_data)

except Exception as e:
    await self.send_to_client(websocket, {
        "type": "error",
        "message": f"Error creating {{ model.name.lower() }}: {str(e)}",
        "timestamp": datetime.now().isoformat()
    })

async def handle_get_{{ model.name.lower() }}(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
"""Handle get {{ model.name.lower() }} request"""
try:
    item_id = data.get("id")
    if not item_id:
        await self.send_to_client(websocket, {
            "type": "error",
            "message": "ID required",
            "timestamp": datetime.now().isoformat()
        })
        return

    {% if api_spec.database_required %}
    with self.db_lock:
        conn = self._get_db_connection()
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM {{ model.name.lower() }}s WHERE id = ?', (item_id,))
        row = cursor.fetchone()
        conn.close()

    if not row:
        await self.send_to_client(websocket, {
            "type": "error",
            "message": "{{ model.name }} not found",
            "timestamp": datetime.now().isoformat()
        })
        return

    response_data = {
        "type": "{{ model.name.lower() }}_data",
        "data": {
            {% for field in model.fields %}
            "{{ field.name }}": row[{{ loop.index0 }}]{% if not loop.last %},{% endif %}
            {% endfor %}
        },
        "timestamp": datetime.now().isoformat()
    }
    {% else %}
    # Mock response
    response_data = {
        "type": "{{ model.name.lower() }}_data",
        "data": {
            "id": item_id,
            {% for field in model.fields %}
            {% if field.name != 'id' %}
            "{{ field.name }}": "Sample {{ field.name }}"{% if not loop.last %},{% endif %}
            {% endif %}
            {% endfor %}
        },
        "timestamp": datetime.now().isoformat()
    }
    {% endif %}

    await self.send_to_client(websocket, response_data)

except Exception as e:
    await self.send_to_client(websocket, {
        "type": "error",
        "message": f"Error getting {{ model.name.lower() }}: {str(e)}",
        "timestamp": datetime.now().isoformat()
    })

async def handle_list_{{ model.name.lower() }}s(self, websocket: websockets.WebSocketServerProtocol, data: Dict[str, Any]):
"""Handle list {{ model.name.lower() }}s request"""
try:
    {% if api_spec.database_required %}
    with self.db_lock:
        conn = self._get_db_connection()
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM {{ model.name.lower() }}s')
        rows = cursor.fetchall()
        conn.close()

    items = []
    for row in rows:
        items.append({
            {% for field in model.fields %}
            "{{ field.name }}": row[{{ loop.index0 }}]{% if not loop.last %},{% endif %}
            {% endfor %}
        })

    response_data = {
        "type": "{{ model.name.lower() }}s_list",
        "data": {
            "items": items,
            "total": len(items)
        },
        "timestamp": datetime.now().isoformat()
    }
    {% else %}
    # Mock response
    response_data = {
        "type": "{{ model.name.lower() }}s_list",
        "data": {
            "items": [
                {
                    "id": 1,
                    {% for field in model.fields %}
                    {% if field.name != 'id' %}
                    "{{ field.name }}": "Sample {{ field.name }}"{% if not loop.last %},{% endif %}
                    {% endif %}
                    {% endfor %}
                }
            ],
            "total": 1
        },
        "timestamp": datetime.now().isoformat()
    }
    {% endif %}

    await self.send_to_client(websocket, response_data)

except Exception as e:
    await self.send_to_client(websocket, {
        "type": "error",
        "message": f"Error listing {{ model.name.lower() }}s: {str(e)}",
        "timestamp": datetime.now().isoformat()
    })

{% endfor %}

async def handle_client(self, websocket: websockets.WebSocketServerProtocol, path: str):
"""Handle client connection"""
await self.register_client(websocket)

try:
    async for message in websocket:
        await self.handle_message(websocket, message)
except websockets.exceptions.ConnectionClosed:
    pass
finally:
    await self.unregister_client(websocket)

def create_server():
"""Create and return WebSocket server"""
server_instance = {{ api_spec.name | title }}WebSocketServer()

return websockets.serve(
server_instance.handle_client,
host=os.getenv('HOST', 'localhost'),
port=int(os.getenv('PORT', '8765'))
)

async def main():
"""Main server function"""
logging.basicConfig(
level=logging.INFO,
format='%(asctime)s - %(levelname)s - %(message)s'
)

server = await create_server()
logging.info(f"{{ api_spec.name | title }} WebSocket server started on ws://localhost:8765")

# Keep server running
await server.wait_closed()

if __name__ == '__main__':
asyncio.run(main())
''',

        'client_example.py': '''"""
WebSocket client example for {{ api_spec.name }}
"""

import asyncio
import websockets
import json
from datetime import datetime

class {{ api_spec.name | title }}Client:
    """Example WebSocket client"""

    def __init__(self, uri="ws://localhost:8765"):
        self.uri = uri
        self.websocket = None

    async def connect(self):
        """Connect to WebSocket server"""
        self.websocket = await websockets.connect(self.uri)
        print(f"Connected to {self.uri}")

    async def disconnect(self):
        """Disconnect from server"""
        if self.websocket:
            await self.websocket.close()
            print("Disconnected from server")

    async def send_message(self, message_data):
        """Send message to server"""
        if self.websocket:
            await self.websocket.send(json.dumps(message_data))

    async def listen_for_messages(self):
        """Listen for incoming messages"""
        try:
            async for message in self.websocket:
                data = json.loads(message)
                await self.handle_message(data)
        except websockets.exceptions.ConnectionClosed:
            print("Connection closed by server")

    async def handle_message(self, data):
        """Handle incoming message"""
        message_type = data.get("type")
        timestamp = data.get("timestamp", "")

        if message_type == "connected":
            print(f"[{timestamp}] {data.get('message')}")
        elif message_type == "chat_message":
            user = data.get("user", "Unknown")
            room = data.get("room", "general")
            message = data.get("message", "")
            print(f"[{room}] {user}: {message}")
        elif message_type == "error":
            print(f"ERROR: {data.get('message')}")
        else:
            print(f"Received: {data}")

    async def run_example(self):
        """Run example client interactions"""
        await self.connect()

        # Start listening for messages
        listen_task = asyncio.create_task(self.listen_for_messages())

        # Wait a bit for connection
        await asyncio.sleep(1)

        # Example interactions
        print("\\n=== Example Interactions ===")

        # Ping server
        await self.send_message({"type": "ping"})
        await asyncio.sleep(1)

        # Join a room
        await self.send_message({
            "type": "join_room",
            "room": "test_room"
        })
        await asyncio.sleep(1)

        # Send chat message
        await self.send_message({
            "type": "chat_message",
            "room": "test_room",
            "user": "TestUser",
            "message": "Hello from WebSocket client!"
        })
        await asyncio.sleep(1)

        {% for model in api_spec.models %}
        # {{ model.name }} operations
        print(f"\\n--- {{ model.name }} Operations ---")

        # Create {{ model.name.lower() }}
        await self.send_message({
            "type": "create_{{ model.name.lower() }}",
            {% for field in model.fields %}
            {% if field.name != 'id' and not field.get('auto_now_add') %}
            "{{ field.name }}": "Test {{ field.name }}",
            {% endif %}
            {% endfor %}
            "broadcast": True
        })
        await asyncio.sleep(1)

        # List {{ model.name.lower() }}s
        await self.send_message({
            "type": "list_{{ model.name.lower() }}s"
        })
        await asyncio.sleep(1)

        {% endfor %}

        # Wait a bit more for responses
        await asyncio.sleep(3)

        # Cancel listening task and disconnect
        listen_task.cancel()
        await self.disconnect()

async def main():
    """Main client function"""
    client = {{ api_spec.name | title }}Client()
    await client.run_example()

if __name__ == '__main__':
    asyncio.run(main())
''',

        'requirements.txt': '''websockets==12.0
{% if api_spec.database_required %}
sqlite3
{% endif %}
python-dotenv==1.0.0
''',

        '.env.example': '''# Environment variables for {{ api_spec.name }}

HOST=localhost
PORT=8765
{% if api_spec.database_required %}
DATABASE_PATH={{ api_spec.name }}.db
{% endif %}
LOG_LEVEL=INFO
'''
        }

        return Environment(loader=DictLoader(templates))

    async def generate(self, api_spec: ApiSpec, output_path: Path) -> Dict[str, str]:
        """Generuje kod WebSocket"""

        await self.file_manager.ensure_directory(output_path)
        generated_files = {}

        # Generuj server
        server_content = self.templates.get_template('server.py').render(api_spec=api_spec)
        server_path = output_path / "server.py"
        await self.file_manager.write_file(server_path, server_content)
        generated_files['server.py'] = str(server_path)

        # Generuj client example
        client_content = self.templates.get_template('client_example.py').render(api_spec=api_spec)
        client_path = output_path / "client_example.py"
        await self.file_manager.write_file(client_path, client_content)
        generated_files['client_example.py'] = str(client_path)

        # Generuj requirements
        req_content = self.templates.get_template('requirements.txt').render(api_spec=api_spec)
        req_path = output_path / "requirements.txt"
        await self.file_manager.write_file(req_path, req_content)
        generated_files['requirements.txt'] = str(req_path)

        # Generuj .env.example
        env_content = self.templates.get_template('.env.example').render(api_spec=api_spec)
        env_path = output_path / ".env.example"
        await self.file_manager.write_file(env_path, env_content)
        generated_files['.env.example'] = str(env_path)

        return generated_files


# text2api/generators/cli_gen.py

"""
Generator dla CLI tools
"""

from pathlib import Path
from typing import Dict
from jinja2 import Environment, DictLoader

from ..core.analyzer import ApiSpec
from ..utils.file_utils import FileManager


class CLIGenerator:
    """Generator CLI tools u≈ºywajƒÖc Click"""

    def __init__(self):
        self.file_manager = FileManager()
        self.templates = self._load_templates()

    def _load_templates(self) -> Environment:
        """≈Åaduje szablony Jinja2 dla CLI"""

        templates = {
            'cli.py': '''#!/usr/bin/env python3
"""
{{ api_spec.description }}
CLI tool generated by text2api
"""

import click
import json
import csv
import os
import sys
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Any
{% if api_spec.database_required %}
import sqlite3
{% endif %}

# Version
__version__ = "1.0.0"

class {{ api_spec.name | title }}CLI:
    """{{ api_spec.description }}"""

    def __init__(self):
        {% if api_spec.database_required %}
        self.db_path = os.getenv('DATABASE_PATH', '{{ api_spec.name }}.db')
        self._init_database()
        {% endif %}
        self.verbose = False

    {% if api_spec.database_required %}
    def _init_database(self):
        """Initialize database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        {% for model in api_spec.models %}
        # Create {{ model.name }} table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS {{model.name.lower()}}s(
                { % for field in model.fields %}
        {{field.name}}
        { % if field.type == 'integer' %}INTEGER
        { % elif field.type == 'string' %}TEXT
        { % elif field.type == 'boolean' %}BOOLEAN
        { % else %}TEXT
        { % endif %}{ % if field.get('primary_key') %} PRIMARY
        KEY
        { % endif %}{ % if not loop.last %}, { % endif %}
        { % endfor %}
        )
        ''')
        {% endfor %}

        conn.commit()
        conn.close()

    def _get_db_connection(self):
        """Get database connection"""
        return sqlite3.connect(self.db_path)
    {% endif %}

    def log(self, message: str, level: str = "INFO"):
        """Log message if verbose mode"""
        if self.verbose:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            click.echo(f"[{timestamp}] {level}: {message}", err=True)

    def error(self, message: str):
        """Display error message"""
        click.echo(click.style(f"Error: {message}", fg="red"), err=True)

    def success(self, message: str):
        """Display success message"""
        click.echo(click.style(f"Success: {message}", fg="green"))

    def warning(self, message: str):
        """Display warning message"""
        click.echo(click.style(f"Warning: {message}", fg="yellow"))

    def info(self, message: str):
        """Display info message"""
        click.echo(click.style(message, fg="blue"))

# Create CLI instance
cli_instance = {{ api_spec.name | title }}CLI()

@click.group()
@click.version_option(version=__version__)
@click.option('--verbose', '-v', is_flag=True, help='Enable verbose output')
@click.pass_context
def cli(ctx, verbose):
    """{{ api_spec.description }}"""
    ctx.ensure_object(dict)
    cli_instance.verbose = verbose

@cli.command()
def status():
    """Check system status"""
    cli_instance.info("=== {{ api_spec.name | title }} Status ===")

    {% if api_spec.database_required %}
    # Check database
    try:
        conn = cli_instance._get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = cursor.fetchall()
        conn.close()

        cli_instance.success(f"Database: Connected ({len(tables)} tables)")
        cli_instance.log(f"Database path: {cli_instance.db_path}")

        {% for model in api_spec.models %}
        # Count {{ model.name.lower() }}s
        conn = cli_instance._get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM {{ model.name.lower() }}s")
        count = cursor.fetchone()[0]
        conn.close()
        cli_instance.info(f"{{ model.name }}s: {count} records")
        {% endfor %}

    except Exception as e:
        cli_instance.error(f"Database error: {e}")
    {% else %}
    cli_instance.success("CLI tool ready")
    {% endif %}

    cli_instance.info(f"Version: {__version__}")

{% for model in api_spec.models %}
# {{ model.name }} commands
@cli.group()
def {{ model.name.lower() }}():
    """{{ model.name }} management commands"""
    pass

@{{ model.name.lower() }}.command()
{% for field in model.fields %}
{% if field.name != 'id' and not field.get('auto_now_add') and not field.get('auto_now') %}
@click.option('--{{ field.name.replace('_', '-') }}', required={{ field.get('required', True) | lower }}, help='{{ field.get("description", field.name) }}')
{% endif %}
{% endfor %}
def create({% for field in model.fields %}{% if field.name != 'id' and not field.get('auto_now_add') and not field.get('auto_now') %}{{ field.name }}{% if not loop.last %}, {% endif %}{% endif %}{% endfor %}):
    """Create new {{ model.name.lower() }}"""
    try:
        {% if api_spec.database_required %}
        conn = cli_instance._get_db_connection()
        cursor = conn.cursor()

        cursor.execute('''
        INSERT
        INTO
        {{model.name.lower()}}
        s({ % for field in model.fields %}{ % if field.name != 'id' and not field.get('auto_now_add') and not field.get(
            'auto_now') %}{{field.name}}
        { % if not loop.last %}, { % endif %}{ % endif %}{ % endfor %})
        VALUES({ % for field in model.fields %}{ % if field.name != 'id' and not field.get(
            'auto_now_add') and not field.get(
            'auto_now') %}?{ % if not loop.last %}, { % endif %}{ % endif %}{ % endfor %})
        ''', ({% for field in model.fields %}{% if field.name != 'id' and not field.get('auto_now_add') and not field.get('auto_now') %}{{ field.name }}{% if not loop.last %}, {% endif %}{% endif %}{% endfor %}))

        item_id = cursor.lastrowid
        conn.commit()
        conn.close()

        cli_instance.success(f"{{ model.name }} created with ID: {item_id}")
        cli_instance.log(f"Created {{ model.name.lower() }}: {{% for field in model.fields %}{% if field.name != 'id' and not field.get('auto_now_add') and not field.get('auto_now') %}{{ field.name }}{% if not loop.last %}, {% endif %}{% endif %}{% endfor %}}")
        {% else %}
        # Mock creation
        cli_instance.success(f"{{ model.name }} would be created: {{% for field in model.fields %}{% if field.name != 'id' and not field.get('auto_now_add') and not field.get('auto_now') %}{{ field.name }}{% if not loop.last %}, {% endif %}{% endif %}{% endfor %}}")
        {% endif %}

    except Exception as e:
        cli_instance.error(f"Failed to create {{ model.name.lower() }}: {e}")
        sys.exit(1)

@{{ model.name.lower() }}.command()
@click.argument('item_id', type=int)
def get(item_id):
    """Get {{ model.name.lower() }} by ID"""
    try:
        {% if api_spec.database_required %}
        conn = cli_instance._get_db_connection()
        cursor = conn.cursor()

        cursor.execute('SELECT * FROM {{ model.name.lower() }}s WHERE id = ?', (item_id,))
        row = cursor.fetchone()
        conn.close()

        if not row:
            cli_instance.error(f"{{ model.name }} with ID {item_id} not found")
            sys.exit(1)

        # Display result
        cli_instance.info(f"{{ model.name }} ID: {item_id}")
        {% for field in model.fields %}
        cli_instance.info(f"  {{ field.name | title }}: {row[{{ loop.index0 }}]}")
        {% endfor %}
        {% else %}
        # Mock response
        cli_instance.info(f"{{ model.name }} ID: {item_id}")
        {% for field in model.fields %}
        {% if field.name != 'id' %}
        cli_instance.info(f"  {{ field.name | title }}: Sample {{ field.name }}")
        {% endif %}
        {% endfor %}
        {% endif %}

    except Exception as e:
        cli_instance.error(f"Failed to get {{ model.name.lower() }}: {e}")
        sys.exit(1)

@{{ model.name.lower() }}.command()
@click.option('--format', type=click.Choice(['table', 'json', 'csv']), default='table', help='Output format')
@click.option('--limit', type=int, help='Limit number of results')
def list(format, limit):
    """List all {{ model.name.lower() }}s"""
    try:
        {% if api_spec.database_required %}
        conn = cli_instance._get_db_connection()
        cursor = conn.cursor()

        query = 'SELECT * FROM {{ model.name.lower() }}s'
        if limit:
            query += f' LIMIT {limit}'

        cursor.execute(query)
        rows = cursor.fetchall()
        conn.close()

        if not rows:
            cli_instance.warning("No {{ model.name.lower() }}s found")
            return

        if format == 'json':
            data = []
            for row in rows:
                data.append({
                    {% for field in model.fields %}
                    '{{ field.name }}': row[{{ loop.index0 }}]{% if not loop.last %},{% endif %}
                    {% endfor %}
                })
            click.echo(json.dumps(data, indent=2))

        elif format == 'csv':
            import io
            output = io.StringIO()
            writer = csv.writer(output)

            # Header
            writer.writerow([{% for field in model.fields %}'{{ field.name }}'{% if not loop.last %}, {% endif %}{% endfor %}])

            # Data
            for row in rows:
                writer.writerow(row)

            click.echo(output.getvalue())

        else:  # table format
            cli_instance.info(f"Found {len(rows)} {{ model.name.lower() }}(s):")
            cli_instance.info("-" * 50)

            for row in rows:
                cli_instance.info(f"ID: {row[0]}")
                {% for field in model.fields %}
                {% if field.name != 'id' %}
                cli_instance.info(f"  {{ field.name | title }}: {row[{{ loop.index0 }}]}")
                {% endif %}
                {% endfor %}
                cli_instance.info("-" * 30)
        {% else %}
        # Mock data
        mock_data = [
            {
                'id': 1,
                {% for field in model.fields %}
                {% if field.name != 'id' %}
                '{{ field.name }}': 'Sample {{ field.name }}'{% if not loop.last %},{% endif %}
                {% endif %}
                {% endfor %}
            }
        ]

        if format == 'json':
            click.echo(json.dumps(mock_data, indent=2))
        else:
            cli_instance.info("Mock {{ model.name.lower() }} data:")
            for item in mock_data:
                for key, value in item.items():
                    cli_instance.info(f"  {key}: {value}")
        {% endif %}

    except Exception as e:
        cli_instance.error(f"Failed to list {{ model.name.lower() }}s: {e}")
        sys.exit(1)

@{{ model.name.lower() }}.command()
@click.argument('item_id', type=int)
@click.confirmation_option(prompt='Are you sure you want to delete this {{ model.name.lower() }}?')
def delete(item_id):
    """Delete {{ model.name.lower() }} by ID"""
    try:
        {% if api_spec.database_required %}
        conn = cli_instance._get_db_connection()
        cursor = conn.cursor()

        cursor.execute('DELETE FROM {{ model.name.lower() }}s WHERE id = ?', (item_id,))

        if cursor.rowcount == 0:
            cli_instance.error(f"{{ model.name }} with ID {item_id} not found")
            sys.exit(1)

        conn.commit()
        conn.close()

        cli_instance.success(f"{{ model.name }} with ID {item_id} deleted")
        {% else %}
        # Mock deletion
        cli_instance.success(f"{{ model.name }} with ID {item_id} would be deleted")
        {% endif %}

    except Exception as e:
        cli_instance.error(f"Failed to delete {{ model.name.lower() }}: {e}")
        sys.exit(1)

@{{ model.name.lower() }}.command()
@click.argument('file_path', type=click.Path(exists=True))
@click.option('--format', type=click.Choice(['json', 'csv']), default='json', help='Input format')
def import_data(file_path, format):
    """Import {{ model.name.lower() }}s from file"""
    try:
        file_path = Path(file_path)

        if format == 'json':
            with open(file_path, 'r') as f:
                data = json.load(f)
        elif format == 'csv':
            data = []
            with open(file_path, 'r') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    data.append(row)

        if not isinstance(data, list):
            data = [data]

        imported_count = 0

        {% if api_spec.database_required %}
        conn = cli_instance._get_db_connection()
        cursor = conn.cursor()

        for item in data:
            try:
                cursor.execute('''
        INSERT
        INTO
        {{model.name.lower()}}
        s({ % for field in model.fields %}{ % if field.name != 'id' and not field.get('auto_now_add') and not field.get(
            'auto_now') %}{{field.name}}
        { % if not loop.last %}, { % endif %}{ % endif %}{ % endfor %})
        VALUES({ % for field in model.fields %}{ % if field.name != 'id' and not field.get(
            'auto_now_add') and not field.get(
            'auto_now') %}?{ % if not loop.last %}, { % endif %}{ % endif %}{ % endfor %})
        ''', ({% for field in model.fields %}{% if field.name != 'id' and not field.get('auto_now_add') and not field.get('auto_now') %}item.get('{{ field.name }}'){% if not loop.last %}, {% endif %}{% endif %}{% endfor %}))
        imported_count += 1
    except Exception as e:
        cli_instance.warning(f"Failed to import item: {e}")

conn.commit()
conn.close()
{% else %}
imported_count = len(data)
{% endif %}

cli_instance.success(f"Imported {imported_count} {{ model.name.lower() }}(s) from {file_path}")

except Exception as e:
cli_instance.error(f"Failed to import data: {e}")
sys.exit(1)

@{{ model.name.lower() }}.command()
@click.argument('file_path', type=click.Path())
@click.option('--format', type=click.Choice(['json', 'csv']), default='json', help='Output format')
def export(file_path, format):
"""Export {{ model.name.lower() }}s to file"""
try:
{% if api_spec.database_required %}
conn = cli_instance._get_db_connection()
cursor = conn.cursor()

cursor.execute('SELECT * FROM {{ model.name.lower() }}s')
rows = cursor.fetchall()
conn.close()

data = []
for row in rows:
    data.append({
        {% for field in model.fields %}
        '{{ field.name }}': row[{{ loop.index0 }}]{% if not loop.last %},{% endif %}
        {% endfor %}
    })
{% else %}
# Mock data for export
data = [
    {
        'id': 1,
        {% for field in model.fields %}
        {% if field.name != 'id' %}
        '{{ field.name }}': 'Sample {{ field.name }}'{% if not loop.last %},{% endif %}
        {% endif %}
        {% endfor %}
    }
]
{% endif %}

file_path = Path(file_path)

if format == 'json':
    with open(file_path, 'w') as f:
        json.dump(data, f, indent=2)
elif format == 'csv':
    with open(file_path, 'w', newline='') as f:
        if data:
            writer = csv.DictWriter(f, fieldnames=data[0].keys())
            writer.writeheader()
            writer.writerows(data)

cli_instance.success(f"Exported {len(data)} {{ model.name.lower() }}(s) to {file_path}")

except Exception as e:
cli_instance.error(f"Failed to export data: {e}")
sys.exit(1)

{% endfor %}

# Utility commands
@cli.group()
def utils():
"""Utility commands"""
pass

@utils.command()
def config():
"""Show configuration"""
cli_instance.info("=== Configuration ===")
{% if api_spec.database_required %}
cli_instance.info(f"Database: {cli_instance.db_path}")
{% endif %}
cli_instance.info(f"Version: {__version__}")

{% if api_spec.database_required %}
@utils.command()
def init_db():
"""Initialize database"""
try:
cli_instance._init_database()
cli_instance.success("Database initialized successfully")
except Exception as e:
cli_instance.error(f"Failed to initialize database: {e}")
sys.exit(1)

@utils.command()
@click.confirmation_option(prompt='Are you sure you want to reset the database?')
def reset_db():
"""Reset database (delete all data)"""
try:
conn = cli_instance._get_db_connection()
cursor = conn.cursor()

{% for model in api_spec.models %}
cursor.execute('DELETE FROM {{ model.name.lower() }}s')
{% endfor %}

conn.commit()
conn.close()

cli_instance.success("Database reset successfully")
except Exception as e:
cli_instance.error(f"Failed to reset database: {e}")
sys.exit(1)
{% endif %}

@utils.command()
def version():
"""Show version information"""
cli_instance.info(f"{{ api_spec.name | title }} CLI v{__version__}")
cli_instance.info("Generated by text2api")

if __name__ == '__main__':
cli()
''',

        'requirements.txt': '''click==8.1.7
{% if api_spec.database_required %}
sqlite3
{% endif %}
python-dotenv==1.0.0
''',

        '.env.example': '''# Environment variables for {{ api_spec.name }}

{% if api_spec.database_required %}
DATABASE_PATH={{ api_spec.name }}.db
{% endif %}
LOG_LEVEL=INFO
CLI_DEBUG=False
''',

        'setup.py': '''"""
Setup script for {{ api_spec.name }} CLI
"""

from setuptools import setup, find_packages

setup(
    name='{{ api_spec.name }}-cli',
    version='1.0.0',
    description='{{ api_spec.description }}',
    author='Generated by text2api',
    py_modules=['cli'],
    install_requires=[
        'click>=8.1.7',
        {% if api_spec.database_required %}
        # sqlite3 is included in Python standard library
        {% endif %}
        'python-dotenv>=1.0.0',
    ],
    entry_points={
        'console_scripts': [
            '{{ api_spec.name }}={{ "cli:cli" }}',
        ],
    },
    classifiers=[
        'Development Status :: 4 - Beta',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: MIT License',
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.9',
        'Programming Language :: Python :: 3.10',
        'Programming Language :: Python :: 3.11',
    ],
    python_requires='>=3.9',
)
'''
        }

        return Environment(loader=DictLoader(templates))

    async def generate(self, api_spec: ApiSpec, output_path: Path) -> Dict[str, str]:
        """Generuje CLI tool"""

        await self.file_manager.ensure_directory(output_path)
        generated_files = {}

        # Generuj CLI
        cli_content = self.templates.get_template('cli.py').render(api_spec=api_spec)
        cli_path = output_path / "cli.py"
        await self.file_manager.write_file(cli_path, cli_content)
        generated_files['cli.py'] = str(cli_path)

        # Generuj requirements
        req_content = self.templates.get_template('requirements.txt').render(api_spec=api_spec)
        req_path = output_path / "requirements.txt"
        await self.file_manager.write_file(req_path, req_content)
        generated_files['requirements.txt'] = str(req_path)

        # Generuj setup.py
        setup_content = self.templates.get_template('setup.py').render(api_spec=api_spec)
        setup_path = output_path / "setup.py"
        await self.file_manager.write_file(setup_path, setup_content)
        generated_files['setup.py'] = str(setup_path)

        # Generuj .env.example
        env_content = self.templates.get_template('.env.example').render(api_spec=api_spec)
        env_path = output_path / ".env.example"
        await self.file_manager.write_file(env_path, env_content)
        generated_files['.env.example'] = str(env_path)

        # Uczy≈Ñ plik CLI wykonywalnym
        import os
        os.chmod(cli_path, 0o755)

        return generated_files  # text2api/generators/grpc_gen.py


"""
Generator dla gRPC API
"""

from pathlib import Path
from typing import Dict
from jinja2 import Environment, DictLoader

from ..core.analyzer import ApiSpec
from ..utils.file_utils import FileManager


class GRPCGenerator:
    """Generator kodu gRPC"""

    def __init__(self):
        self.file_manager = FileManager()
        self.templates = self._load_templates()

    def _load_templates(self) -> Environment:
        """≈Åaduje szablony Jinja2 dla gRPC"""

        templates = {
            'service.proto': '''syntax = "proto3";

package {{ api_spec.name }};

// {{ api_spec.description }}

{% for model in api_spec.models %}
message {{ model.name }} {
  {% for field in model.fields %}
  {% set field_type = field.type | proto_type %}
  {% if field.get('repeated') %}repeated {% endif %}{{ field_type }} {{ field.name }} = {{ loop.index }};
  {% endfor %}
}

message {{ model.name }}Request {
  {% for field in model.fields %}
  {% if field.name != 'id' and not field.get('auto_now_add') %}
  {% set field_type = field.type | proto_type %}
  {{ field_type }} {{ field.name }} = {{ loop.index }};
  {% endif %}
  {% endfor %}
}

message {{ model.name }}List {
  repeated {{ model.name }} items = 1;
  int32 total = 2;
}

{% endfor %}

message Empty {}

message IdRequest {
  int32 id = 1;
}

message HealthResponse {
  string status = 1;
  string message = 2;
}

// Service definition
service {{ api_spec.name | title }}Service {
  // Health check
  rpc Health(Empty) returns (HealthResponse);

  {% for model in api_spec.models %}
  // {{ model.name }} operations
  rpc Create{{ model.name }}({{ model.name }}Request) returns ({{ model.name }});
  rpc Get{{ model.name }}(IdRequest) returns ({{ model.name }});
  rpc List{{ model.name }}s(Empty) returns ({{ model.name }}List);
  rpc Update{{ model.name }}({{ model.name }}) returns ({{ model.name }});
  rpc Delete{{ model.name }}(IdRequest) returns (Empty);
  {% endfor %}
}
''',

            'server.py': '''"""
gRPC server generated by text2api
"""

import grpc
from concurrent import futures
import time
import logging
import os
{% if api_spec.database_required %}
import sqlite3
from typing import List, Optional
{% endif %}

# Generated protobuf imports
import {{ api_spec.name }}_pb2
import {{ api_spec.name }}_pb2_grpc

class {{ api_spec.name | title }}Service({{ api_spec.name }}_pb2_grpc.{{ api_spec.name | title }}ServiceServicer):
    """{{ api_spec.description }}"""

    def __init__(self):
        {% if api_spec.database_required %}
        self.db_path = "{{ api_spec.name }}.db"
        self._init_database()
        {% endif %}
        logging.info("{{ api_spec.name | title }}Service initialized")

    {% if api_spec.database_required %}
    def _init_database(self):
        """Initialize SQLite database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        {% for model in api_spec.models %}
        # Create {{ model.name }} table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS {{model.name.lower()}}s(
                { % for field in model.fields %}
        {{field.name}}
        { % if field.type == 'integer' %}INTEGER
        { % elif field.type == 'string' %}TEXT
        { % elif field.type == 'boolean' %}BOOLEAN
        { % else %}TEXT
        { % endif %}{ % if field.get('primary_key') %} PRIMARY
        KEY
        { % endif %}{ % if not loop.last %}, { % endif %}
        { % endfor %}
        )
        ''')
        {% endfor %}

        conn.commit()
        conn.close()

    def _get_db_connection(self):
        """Get database connection"""
        return sqlite3.connect(self.db_path)
    {% endif %}

    def Health(self, request, context):
        """Health check endpoint"""
        return {{ api_spec.name }}_pb2.HealthResponse(
            status="OK",
            message="{{ api_spec.description }} is running"
        )

    {% for model in api_spec.models %}
    def Create{{ model.name }}(self, request, context):
        """Create new {{ model.name.lower() }}"""
        try:
            {% if api_spec.database_required %}
            conn = self._get_db_connection()
            cursor = conn.cursor()

            cursor.execute('''
        INSERT
        INTO
        {{model.name.lower()}}
        s({ % for field in model.fields %}{ % if field.name != 'id' and not field.get('auto_now_add') %}{{field.name}}
        { % if not loop.last %}, { % endif %}{ % endif %}{ % endfor %})
        VALUES({ % for field in model.fields %}{ % if field.name != 'id' and not field.get(
            'auto_now_add') %}?{ % if not loop.last %}, { % endif %}{ % endif %}{ % endfor %})
        ''', ({% for field in model.fields %}{% if field.name != 'id' and not field.get('auto_now_add') %}request.{{ field.name }}{% if not loop.last %}, {% endif %}{% endif %}{% endfor %}))

        item_id = cursor.lastrowid
        conn.commit()
        conn.close()

        return {{ api_spec.name }}_pb2.{{ model.name }}(
            id=item_id,
            {% for field in model.fields %}
            {% if field.name != 'id' and not field.get('auto_now_add') %}
            {{ field.name }}=request.{{ field.name }}{% if not loop.last %},{% endif %}
            {% endif %}
            {% endfor %}
        )
        {% else %}
        # Mock response
        return {{ api_spec.name }}_pb2.{{ model.name }}(
            id=1,
            {% for field in model.fields %}
            {% if field.name != 'id' and not field.get('auto_now_add') %}
            {{ field.name }}=request.{{ field.name }}{% if not loop.last %},{% endif %}
            {% endif %}
            {% endfor %}
        )
        {% endif %}
    except Exception as e:
        context.set_code(grpc.StatusCode.INTERNAL)
        context.set_details(f'Error creating {{ model.name.lower() }}: {str(e)}')
        return {{ api_spec.name }}_pb2.{{ model.name }}()

def Get{{ model.name }}(self, request, context):
    """Get {{ model.name.lower() }} by ID"""
    try:
        {% if api_spec.database_required %}
        conn = self._get_db_connection()
        cursor = conn.cursor()

        cursor.execute('SELECT * FROM {{ model.name.lower() }}s WHERE id = ?', (request.id,))
        row = cursor.fetchone()
        conn.close()

        if not row:
            context.set_code(grpc.StatusCode.NOT_FOUND)
            context.set_details('{{ model.name }} not found')
            return {{ api_spec.name }}_pb2.{{ model.name }}()

        return {{ api_spec.name }}_pb2.{{ model.name }}(
            {% for field in model.fields %}
            {{ field.name }}=row[{{ loop.index0 }}]{% if not loop.last %},{% endif %}
            {% endfor %}
        )
        {% else %}
        # Mock response
        return {{ api_spec.name }}_pb2.{{ model.name }}(
            id=request.id,
            {% for field in model.fields %}
            {% if field.name != 'id' %}
            {{ field.name }}="Sample {{ field.name }}"{% if not loop.last %},{% endif %}
            {% endif %}
            {% endfor %}
        )
        {% endif %}
    except Exception as e:
        context.set_code(grpc.StatusCode.INTERNAL)
        context.set_details(f'Error getting {{ model.name.lower() }}: {str(e)}')
        return {{ api_spec.name }}_pb2.{{ model.name }}()

def List{{ model.name }}s(self, request, context):
    """List all {{ model.name.lower() }}s"""
    try:
        {% if api_spec.database_required %}
        conn = self._get_db_connection()
        cursor = conn.cursor()

        cursor.execute('SELECT * FROM {{ model.name.lower() }}s')
        rows = cursor.fetchall()
        conn.close()

        items = []
        for row in rows:
            item = {{ api_spec.name }}_pb2.{{ model.name }}(
                {% for field in model.fields %}
                {{ field.name }}=row[{{ loop.index0 }}]{% if not loop.last %},{% endif %}
                {% endfor %}
            )
            items.append(item)

        return {{ api_spec.name }}_pb2.{{ model.name }}List(
            items=items,
            total=len(items)
        )
        {% else %}
        # Mock response
        items = [
            {{ api_spec.name }}_pb2.{{ model.name }}(
                id=1,
                {% for field in model.fields %}
                {% if field.name != 'id' %}
                {{ field.name }}="Sample {{ field.name }}"{% if not loop.last %},{% endif %}
                {% endif %}
                {% endfor %}
            )
        ]

        return {{ api_spec.name }}_pb2.{{ model.name }}List(
            items=items,
            total=len(items)
        )
        {% endif %}
    except Exception as e:
        context.set_code(grpc.StatusCode.INTERNAL)
        context.set_details(f'Error listing {{ model.name.lower() }}s: {str(e)}')
        return {{ api_spec.name }}_pb2.{{ model.name }}List()

def Update{{ model.name }}(self, request, context):
    """Update {{ model.name.lower() }}"""
    try:
        {% if api_spec.database_required %}
        conn = self._get_db_connection()
        cursor = conn.cursor()

        cursor.execute('''
        UPDATE
        {{model.name.lower()}}
        s
        SET
        { %
        for field in model.fields %}{% if field.name != 'id' and not field.get('auto_now_add') %}{{field.name}} = ?{% if not loop.last %}, {%endif %}{%endif %}{%endfor %}
        WHERE id = ?
        ''', ({% for field in model.fields %}{% if field.name != 'id' and not field.get('auto_now_add') %}request.{{ field.name }}, {% endif %}{% endfor %}request.id))

        if cursor.rowcount == 0:
            context.set_code(grpc.StatusCode.NOT_FOUND)
            context.set_details('{{ model.name }} not found')
            return {{ api_spec.name }}_pb2.{{ model.name }}()

        conn.commit()
        conn.close()

        return request
        {% else %}
        # Mock response
        return request
        {% endif %}
    except Exception as e:
        context.set_code(grpc.StatusCode.INTERNAL)
        context.set_details(f'Error updating {{ model.name.lower() }}: {str(e)}')
        return {{ api_spec.name }}_pb2.{{ model.name }}()

def Delete{{ model.name }}(self, request, context):
    """Delete {{ model.name.lower() }}"""
    try:
        {% if api_spec.database_required %}
        conn = self._get_db_connection()
        cursor = conn.cursor()

        cursor.execute('DELETE FROM {{ model.name.lower() }}s WHERE id = ?', (request.id,))

        if cursor.rowcount == 0:
            context.set_code(grpc.StatusCode.NOT_FOUND)
            context.set_details('{{ model.name }} not found')

        conn.commit()
        conn.close()
        {% endif %}

        return {{ api_spec.name }}_pb2.Empty()
    except Exception as e:
        context.set_code(grpc.StatusCode.INTERNAL)
        context.set_details(f'Error deleting {{ model.name.lower() }}: {str(e)}')
        return {{ api_spec.name }}_pb2.Empty()

{% endfor %}

def serve():
"""Start gRPC server"""
server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
{{ api_spec.name }}_pb2_grpc.add_{{ api_spec.name | title }}ServiceServicer_to_server(
    {{ api_spec.name | title }}Service(), server
)

port = os.getenv('GRPC_PORT', '50051')
server.add_insecure_port(f'[::]:{port}')

server.start()
logging.info(f"gRPC server started on port {port}")

try:
    while True:
        time.sleep(86400)  # Keep server running
except KeyboardInterrupt:
    logging.info("Stopping gRPC server...")
    server.stop(0)

if __name__ == '__main__':
logging.basicConfig(level=logging.INFO)
serve()
''',

        'client.py': '''"""
gRPC client example for {{ api_spec.name }}
"""

import grpc
import {{ api_spec.name }}_pb2
import {{ api_spec.name }}_pb2_grpc

def run_client():
    """Example gRPC client"""

    # Connect to server
    with grpc.insecure_channel('localhost:50051') as channel:
        stub = {{ api_spec.name }}_pb2_grpc.{{ api_spec.name | title }}ServiceStub(channel)

        # Health check
        print("=== Health Check ===")
        health_response = stub.Health({{ api_spec.name }}_pb2.Empty())
        print(f"Status: {health_response.status}")
        print(f"Message: {health_response.message}")

        {% for model in api_spec.models %}
        # {{ model.name }} operations
        print(f"\\n=== {{ model.name }} Operations ===")

        # Create
        create_request = {{ api_spec.name }}_pb2.{{ model.name }}Request(
            {% for field in model.fields %}
            {% if field.name != 'id' and not field.get('auto_now_add') %}
            {{ field.name }}="Test {{ field.name }}"{% if not loop.last %},{% endif %}
            {% endif %}
            {% endfor %}
        )

        created_{{ model.name.lower() }} = stub.Create{{ model.name }}(create_request)
        print(f"Created {{ model.name.lower() }}: {created_{{ model.name.lower() }}}")

        # Get
        get_request = {{ api_spec.name }}_pb2.IdRequest(id=created_{{ model.name.lower() }}.id)
        {{ model.name.lower() }} = stub.Get{{ model.name }}(get_request)
        print(f"Retrieved {{ model.name.lower() }}: {{ model.name.lower() }}")

        # List
        {{ model.name.lower() }}_list = stub.List{{ model.name }}s({{ api_spec.name }}_pb2.Empty())
        print(f"{{ model.name }} list: {len({{ model.name.lower() }}_list.items)} items")

        {% endfor %}

if __name__ == '__main__':
    run_client()
''',

        'requirements.txt': '''grpcio==1.60.0
grpcio-tools==1.60.0
protobuf==4.25.1
{% if api_spec.database_required %}
sqlite3
{% endif %}
'''
        }

        return Environment(loader=DictLoader(templates))

    def _load_filters(self):
        """Dodaje custom filtry"""

        def proto_type(field_type):
            """Konwertuje typy na protobuf types"""
            mapping = {
                'integer': 'int32',
                'string': 'string',
                'boolean': 'bool',
                'float': 'float',
                'datetime': 'string'
            }
            return mapping.get(field_type, 'string')

        self.templates.filters['proto_type'] = proto_type

    async def generate(self, api_spec: ApiSpec, output_path: Path) -> Dict[str, str]:
        """Generuje kod gRPC"""

        await self.file_manager.ensure_directory(output_path)
        self._load_filters()

        generated_files = {}

        # Generuj proto file
        proto_content = self.templates.get_template('service.proto').render(api_spec=api_spec)
        proto_path = output_path / f"{api_spec.name}.proto"
        await self.file_manager.write_file(proto_path, proto_content)
        generated_files[f'{api_spec.name}.proto'] = str(proto_path)

        # Generuj server
        server_content = self.templates.get_template('server.py').render(api_spec=api_spec)
        server_path = output_path / "server.py"
        await self.file_manager.write_file(server_path, server_content)
        generated_files['server.py'] = str(server_path)

        # Generuj client example
        client_content = self.templates.get_template('client.py').render(api_spec=api_spec)
        client_path = output_path / "client.py"
        await self.file_manager.write_file(client_path, client_content)
        generated_files['client.py'] = str(client_path)

        # Generuj requirements
        req_content = self.templates.get_template('requirements.txt').render(api_spec=api_spec)
        req_path = output_path / "requirements.txt"
        await self.file_manager.write_file(req_path, req_content)
        generated_files['requirements.txt'] = str(req_path)

        # Generuj protobuf compilation script
        compile_script = f'''#!/bin/bash
# Compile protobuf files

python -m grpc_tools.protoc \\
    --proto_path=. \\
    --python_out=. \\
    --grpc_python_out=. \\
    {api_spec.name}.proto

echo "Protobuf files compiled successfully"
'''

        script_path = output_path / "compile_proto.sh"
        await self.file_manager.write_file(script_path, compile_script)
        generated_files['compile_proto.sh'] = str(script_path)

        return generated_files